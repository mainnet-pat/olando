// Olando Community Issuance Fund Contract
// Each time an investor buys tokens from the cauldron pool, the contract emits extra tokens to the council.
// The contract is deployed with a fixed supply of 8,888,888,888.88 tokens.
// The contract emits tokens based on the time since deployment and the amount of tokens bought so far.
// The contract can be migrated to a new issuance or dissolved to release tokens to the admin.
contract IssuanceFund(bytes councilFundLockingBytecode) {

  // invest into Olando ecosystem by buying tokens from the cauldron pool
  // tx layout:
  //  inputs:
  //   0: issuance fund input, NFT commitment: 4bytes deployment time + 4bytes last interaction time
  //   1: investors BCH input to balance the council's OLA share payout
  //   2..N: cauldron pool inputs
  //   N+1: investment BCH, no tokens
  //  outputs:
  //   0: issuance fund output, NFT commitment: 4bytes deployment time + 4bytes new interaction time (tx.locktime)
  //   1: council OLA share output, see notes for amounts
  //   2..N: cauldron pool outputs, same properties as inputs but with reduced token amount
  //   N+1: investors OLA share output, see notes for amounts
  //   N+2: BCH change output
  //
  // Notes: if the issuance cap is not hit at the time of interaction, then ola bought from cauldron by investor
  // are augmented with 90% of the tokens bought, the OLA amounts are added together and split in half.
  // If the issuance cap is hit the contract execution fails, suggesting the investor to buy less tokens.
  function issue() {
    // first rough check for presence of a cauldron trade
    require(tx.inputs.length >= 4, "Issue transaction must have at least 4 inputs");
    require(tx.outputs.length >= 5, "Issue transaction must have at least 5 outputs");

    int deploymentTime = int(tx.inputs[this.activeInputIndex].nftCommitment.split(4)[0]);
    int lastInteractionTime = int(tx.inputs[this.activeInputIndex].nftCommitment.split(4)[1]);
    require(tx.locktime > lastInteractionTime, "Current time is before last interaction time");

    int intialSupply = 8888888888888_88; // with 2 decimals
    int issued = intialSupply - tx.inputs[this.activeInputIndex].tokenAmount;

    int SCALE = 1_000_000_000; // 1e9 for scaling
    int t = tx.locktime - deploymentTime; // time in seconds since deploymentTime
    console.log(t, "time since start");
    int k = 3; // 3E-9 scaled by 1e9
    int denom = SCALE + k * t; // (1 + 3E-9 * t) * 1e9
    int denomSquared = denom * denom / SCALE; // (1 + 3E-9 * t)^2 * 1e9
    int currentEmissionCap = intialSupply * (SCALE - SCALE * SCALE / denomSquared) / SCALE;
    console.log(currentEmissionCap, "current emission cap");

    // use inputs.length to find the cauldron token-buy output, since last ouput could be a bch change
    // here we already assume that the cauldron pool output got only 95% of the tokens bought, the other 5% are forwarded to council fund
    int tokensBought = 100 * tx.outputs[tx.inputs.length - 1].tokenAmount / 95;
    int issue = tokensBought * 9 / 10; // 90% of tokens bought
    require(issue <= currentEmissionCap - issued, "Issue amount exceeds current emission cap");
    int issueShare = (tokensBought + issue) / 2;

    console.log("investorShare", issueShare, "fundShare", issueShare, "issue", issue, "tokensBought", tokensBought);

    // constrain the input 0 and output 0 to be the issuance fund
    require(this.activeInputIndex == 0, "Active input index must be 0 for issuance contract");
    require(tx.outputs[this.activeInputIndex].tokenAmount == (tx.inputs[this.activeInputIndex].tokenAmount - issueShare - issueShare), "Wrong amount of tokens issued");
    require(tx.outputs[this.activeInputIndex].tokenCategory == tx.inputs[this.activeInputIndex].tokenCategory, "Can not change token category");
    require(tx.outputs[this.activeInputIndex].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode, "Can not change locking bytecode");
    require(tx.outputs[this.activeInputIndex].nftCommitment == bytes(deploymentTime) + bytes(tx.locktime), "NFT commitment must be updated with current time");

    // constrain the output 1 to be the council fund share
    require(tx.outputs[1].tokenCategory == tx.inputs[this.activeInputIndex].tokenCategory.split(32)[0], "Council fund share must have the same token category, no nft");
    require(tx.outputs[1].tokenAmount == issueShare, "Council fund share must match the calculated fund share");
    require(tx.outputs[1].lockingBytecode == councilFundLockingBytecode, "Council fund share must have the correct locking bytecode");
    require(tx.outputs[1].value == 1000, "Council fund share must have a value of 1000 satoshis");

    // constrain the output N+1 to be the investor's share
    int investorShareIndex = tx.outputs.length - 2;
    require(tx.outputs[investorShareIndex].tokenCategory == tx.inputs[this.activeInputIndex].tokenCategory.split(32)[0], "Investor's share must have the same token category, no nft");
    require(tx.outputs[investorShareIndex].tokenAmount == issueShare, "Investor's share must match the calculated share");
    require(tx.outputs[investorShareIndex].lockingBytecode == tx.inputs[1].lockingBytecode, "Investor's share must have the correct locking bytecode");
    require(tx.outputs[investorShareIndex].value == 1000, "Investor's share must have a value of 1000 satoshis");


    // constrain the cauldron inputs and outputs 2..N
    bytes cauldronPoolContractSignature = 0xc94c0d3957ca2608827700a0; // signature of cauldron pool contract
    int cauldronPoolContractSignatureSplit = 2;

    int index = this.activeInputIndex + 1; // 0
    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

// #region 20 more cauldron pool input-output checks
    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }

    index = index + 1; // cauldron pool token output
    if (index + 1 < tx.inputs.length) {
      console.log("Checking cauldron pool input and output at index", index);
      require(tx.inputs[index].unlockingBytecode.split(cauldronPoolContractSignatureSplit)[1] == cauldronPoolContractSignature, "Cauldron pool contract signature must match");

      require(tx.outputs[index].tokenCategory == tx.inputs[index].tokenCategory, "Cauldron pool token category must remain the same");
      require(tx.outputs[index].nftCommitment == tx.inputs[index].nftCommitment, "Cauldron pool token commitment must remain the same");
      require(tx.outputs[index].lockingBytecode == tx.inputs[index].lockingBytecode, "Cauldron pool token locking bytecode must remain the same");
      require(tx.outputs[index].tokenAmount < tx.inputs[index].tokenAmount, "Cauldron pool token amount must be less than input amount");
      require(tx.outputs[index].value > tx.inputs[index].value, "Cauldron pool satoshi output value must be greater than input value");
    }
// #endregion
  }

  // migrate contract to a new issuance fund contract
  // tx layout:
  //  inputs:
  //   0: issuance fund input
  //   1: admin NFT input
  //   2: funding input
  //  outputs:
  //   0: issuance fund output. all same properties but new locking bytecode
  //   1: admin NFT output, same as input
  //   2: bch change output
  function migrate(bytes newLockingBytecode) {
    require(this.activeInputIndex == 0, "Active input index must be 0");
    require(tx.inputs.length == 3, "Migration requires exactly 3 inputs");
    require(tx.outputs.length == 3, "Migration requires exactly 3 outputs");

    require(tx.outputs[0].lockingBytecode == newLockingBytecode, "New locking bytecode must be provided for the issuance fund output");
    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory, "Token category must remain the same");
    require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount, "Token amount must remain the same");
    require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment, "NFT commitment must remain the same");
    require(tx.outputs[0].value == tx.inputs[0].value, "Output value must remain the same");

    // preserve admin NFT: same category
    require(tx.inputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0], "Second input must have the same token category as the first input");
    require(tx.inputs[1].tokenCategory.length == 32, "Second input must have 'none' capability");
    require(tx.inputs[1].nftCommitment == 0x61646D696E, "Second input must have 'admin' commitment");
    require(tx.outputs[1].lockingBytecode == tx.inputs[1].lockingBytecode, "Locking bytecode must remain the same for second output");

    // bch change output is not burdened with any requirements
  }

  // dissolve contract and release tokens to admin
  // tx layout:
  //  inputs:
  //   0: issuance fund input
  //   1: admin NFT input
  //   2: funding input
  //  outputs:
  //   0: same properties as input 0 paid to admin p2pkh
  //   1: bch change output
  function dissolve() {
    require(this.activeInputIndex == 0, "Active input index must be 0");
    require(tx.inputs.length == 3, "Dissolve requires exactly 3 inputs");
    require(tx.outputs.length == 2, "Dissolve requires exactly 2 outputs");

    require(tx.outputs[0].lockingBytecode == tx.inputs[1].lockingBytecode, "Locking bytecode must be the same as admin p2pkh input");
    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory, "Token category must remain the same");
    require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount, "Token amount must remain the same");
    require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment, "NFT commitment must remain the same");
    require(tx.outputs[0].value == tx.inputs[0].value, "Output value must remain the same");

    // bch change output is not burdened with any requirements
  }
}
